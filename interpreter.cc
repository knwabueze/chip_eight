#include "interpreter.hh"

using namespace Interpreter;

Chip8::Chip8()
	: PC(0), SP(0), delay_timer(0), sound_timer(0), I(0)
{
	memset(GFX, 0, WIDTH * HEIGHT); // Reset GFX
	memset(RAM, 0, 0x1000); // Reset RAM
	memset(Stack, 0, 0x10); // Reset Stack
	memset(V, 0, 0x10); // Reset general purpose registers
	memset(Keypad, 0, 0x10); // Reset keyboard

	// Load fonts into RAM
	std::vector<unsigned char> fonts = {
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	};

	fonts.shrink_to_fit(); // throw away that rubbish mentality

	for (size_t i = 0; i < fonts.size(); ++i)
		RAM[i] = fonts[i];
}

Chip8::~Chip8()
{
	SDL_DestroyWindow(window);
	SDL_DestroyRenderer(renderer);
	SDL_Quit();
}

void Chip8::reset()
{
	PC = 0; SP = 0; delay_timer = 0; sound_timer = 0; I = 0; // Reset registers
	memset(GFX, 0, WIDTH * HEIGHT); // Reset GFX
	memset(RAM, 0, 0x1000); // Reset RAM
	memset(Stack, 0, 0x10); // Reset Stack
	memset(V, 0, 0x10); // Reset general purpose registers
	memset(Keypad, 0, 0x10); // Reset keyboard

	// Load fonts into RAM
	std::vector<unsigned char> fonts = {
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	};

	fonts.shrink_to_fit(); // throw away that rubbish mentality

	for (size_t i = 0; i < fonts.size(); ++i)
		RAM[i] = fonts[i];
}

void Chip8::load_rom(const std::string& path)
{
	std::ifstream file;
	unsigned file_size;

	file.open(path, std::ios::binary);

	if (file.is_open())
	{
		file.seekg(0, std::ios::end);
		file_size = static_cast<unsigned>(file.tellg());

		if (file_size <= 0x1000 - 0x200) // file size is correct size
		{
			char* prg_start = reinterpret_cast<char *>(&(RAM[0x200])); // Start at address 0x200

			file.seekg(0, std::ios::beg);
			file.read(prg_start, file_size);

			PC = 0x200;
		}

		file.close();
	}
}

void Chip8::emulate_cycle()
{
	unsigned short opcode = (RAM[PC] << 8) | RAM[PC + 1];
	
	std::printf("Current Execution Address >> 0x%X | Current Instruction >> 0x%04X\n", PC, opcode);

	switch (opcode & 0xF000)
	{
	case 0x0000: // CLS or RET
		if (opcode == 0x00E0) // CLS
		{
			memset(GFX, 0, sizeof(GFX[0][0]) * WIDTH * HEIGHT);
			std::printf("CLS\n");
			redraw_flag = true;
		}
		else if (opcode == 0x00EE) // RET
		{
			PC = Stack[SP--];
		}
		break;
	case 0x1000: // JP addr		
		PC = opcode & 0x0FFF;
		std::printf("JP 0x%03X\n", (opcode & 0x0FFF));
		break;
	case 0x2000: // CALL
		break;
	}
}

void Chip8::render()
{
}

void Chip8::keystates()
{
}
